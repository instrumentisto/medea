// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `api.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct CreateRequest {
    // message fields
    pub parent_fid: ::std::string::String,
    // message oneof groups
    pub el: ::std::option::Option<CreateRequest_oneof_el>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateRequest {
    fn default() -> &'a CreateRequest {
        <CreateRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CreateRequest_oneof_el {
    member(Member),
    room(Room),
    webrtc_play(WebRtcPlayEndpoint),
    webrtc_pub(WebRtcPublishEndpoint),
}

impl CreateRequest {
    pub fn new() -> CreateRequest {
        ::std::default::Default::default()
    }

    // string parent_fid = 1;


    pub fn get_parent_fid(&self) -> &str {
        &self.parent_fid
    }
    pub fn clear_parent_fid(&mut self) {
        self.parent_fid.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_fid(&mut self, v: ::std::string::String) {
        self.parent_fid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_fid(&mut self) -> &mut ::std::string::String {
        &mut self.parent_fid
    }

    // Take field
    pub fn take_parent_fid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent_fid, ::std::string::String::new())
    }

    // .medea.Member member = 2;


    pub fn get_member(&self) -> &Member {
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::member(ref v)) => v,
            _ => Member::default_instance(),
        }
    }
    pub fn clear_member(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_member(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::member(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: Member) {
        self.el = ::std::option::Option::Some(CreateRequest_oneof_el::member(v))
    }

    // Mutable pointer to the field.
    pub fn mut_member(&mut self) -> &mut Member {
        if let ::std::option::Option::Some(CreateRequest_oneof_el::member(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(CreateRequest_oneof_el::member(Member::new()));
        }
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::member(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_member(&mut self) -> Member {
        if self.has_member() {
            match self.el.take() {
                ::std::option::Option::Some(CreateRequest_oneof_el::member(v)) => v,
                _ => panic!(),
            }
        } else {
            Member::new()
        }
    }

    // .medea.Room room = 3;


    pub fn get_room(&self) -> &Room {
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::room(ref v)) => v,
            _ => Room::default_instance(),
        }
    }
    pub fn clear_room(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_room(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::room(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_room(&mut self, v: Room) {
        self.el = ::std::option::Option::Some(CreateRequest_oneof_el::room(v))
    }

    // Mutable pointer to the field.
    pub fn mut_room(&mut self) -> &mut Room {
        if let ::std::option::Option::Some(CreateRequest_oneof_el::room(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(CreateRequest_oneof_el::room(Room::new()));
        }
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::room(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_room(&mut self) -> Room {
        if self.has_room() {
            match self.el.take() {
                ::std::option::Option::Some(CreateRequest_oneof_el::room(v)) => v,
                _ => panic!(),
            }
        } else {
            Room::new()
        }
    }

    // .medea.WebRtcPlayEndpoint webrtc_play = 4;


    pub fn get_webrtc_play(&self) -> &WebRtcPlayEndpoint {
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_play(ref v)) => v,
            _ => WebRtcPlayEndpoint::default_instance(),
        }
    }
    pub fn clear_webrtc_play(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_webrtc_play(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_play(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_webrtc_play(&mut self, v: WebRtcPlayEndpoint) {
        self.el = ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_play(v))
    }

    // Mutable pointer to the field.
    pub fn mut_webrtc_play(&mut self) -> &mut WebRtcPlayEndpoint {
        if let ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_play(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_play(WebRtcPlayEndpoint::new()));
        }
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_play(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_webrtc_play(&mut self) -> WebRtcPlayEndpoint {
        if self.has_webrtc_play() {
            match self.el.take() {
                ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_play(v)) => v,
                _ => panic!(),
            }
        } else {
            WebRtcPlayEndpoint::new()
        }
    }

    // .medea.WebRtcPublishEndpoint webrtc_pub = 5;


    pub fn get_webrtc_pub(&self) -> &WebRtcPublishEndpoint {
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_pub(ref v)) => v,
            _ => WebRtcPublishEndpoint::default_instance(),
        }
    }
    pub fn clear_webrtc_pub(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_webrtc_pub(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_pub(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_webrtc_pub(&mut self, v: WebRtcPublishEndpoint) {
        self.el = ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_pub(v))
    }

    // Mutable pointer to the field.
    pub fn mut_webrtc_pub(&mut self) -> &mut WebRtcPublishEndpoint {
        if let ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_pub(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_pub(WebRtcPublishEndpoint::new()));
        }
        match self.el {
            ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_pub(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_webrtc_pub(&mut self) -> WebRtcPublishEndpoint {
        if self.has_webrtc_pub() {
            match self.el.take() {
                ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_pub(v)) => v,
                _ => panic!(),
            }
        } else {
            WebRtcPublishEndpoint::new()
        }
    }
}

impl ::protobuf::Message for CreateRequest {
    fn is_initialized(&self) -> bool {
        if let Some(CreateRequest_oneof_el::member(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateRequest_oneof_el::room(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateRequest_oneof_el::webrtc_play(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CreateRequest_oneof_el::webrtc_pub(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent_fid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(CreateRequest_oneof_el::member(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(CreateRequest_oneof_el::room(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_play(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(CreateRequest_oneof_el::webrtc_pub(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent_fid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent_fid);
        }
        if let ::std::option::Option::Some(ref v) = self.el {
            match v {
                &CreateRequest_oneof_el::member(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateRequest_oneof_el::room(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateRequest_oneof_el::webrtc_play(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CreateRequest_oneof_el::webrtc_pub(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent_fid.is_empty() {
            os.write_string(1, &self.parent_fid)?;
        }
        if let ::std::option::Option::Some(ref v) = self.el {
            match v {
                &CreateRequest_oneof_el::member(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateRequest_oneof_el::room(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateRequest_oneof_el::webrtc_play(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CreateRequest_oneof_el::webrtc_pub(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateRequest {
        CreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent_fid",
                    |m: &CreateRequest| { &m.parent_fid },
                    |m: &mut CreateRequest| { &mut m.parent_fid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Member>(
                    "member",
                    CreateRequest::has_member,
                    CreateRequest::get_member,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Room>(
                    "room",
                    CreateRequest::has_room,
                    CreateRequest::get_room,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WebRtcPlayEndpoint>(
                    "webrtc_play",
                    CreateRequest::has_webrtc_play,
                    CreateRequest::get_webrtc_play,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WebRtcPublishEndpoint>(
                    "webrtc_pub",
                    CreateRequest::has_webrtc_pub,
                    CreateRequest::get_webrtc_pub,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateRequest>(
                    "CreateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateRequest,
        };
        unsafe {
            instance.get(CreateRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateRequest {
    fn clear(&mut self) {
        self.parent_fid.clear();
        self.el = ::std::option::Option::None;
        self.el = ::std::option::Option::None;
        self.el = ::std::option::Option::None;
        self.el = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdRequest {
    // message fields
    pub fid: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdRequest {
    fn default() -> &'a IdRequest {
        <IdRequest as ::protobuf::Message>::default_instance()
    }
}

impl IdRequest {
    pub fn new() -> IdRequest {
        ::std::default::Default::default()
    }

    // repeated string fid = 1;


    pub fn get_fid(&self) -> &[::std::string::String] {
        &self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid.clear();
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.fid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fid(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.fid
    }

    // Take field
    pub fn take_fid(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.fid, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for IdRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fid {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fid {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdRequest {
        IdRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fid",
                    |m: &IdRequest| { &m.fid },
                    |m: &mut IdRequest| { &mut m.fid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IdRequest>(
                    "IdRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IdRequest {
        static mut instance: ::protobuf::lazy::Lazy<IdRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IdRequest,
        };
        unsafe {
            instance.get(IdRequest::new)
        }
    }
}

impl ::protobuf::Clear for IdRequest {
    fn clear(&mut self) {
        self.fid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // .medea.Error error = 1;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "error",
                    |m: &Response| { &m.error },
                    |m: &mut Response| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response>(
                    "Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response {
        static mut instance: ::protobuf::lazy::Lazy<Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response,
        };
        unsafe {
            instance.get(Response::new)
        }
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResponse {
    // message fields
    pub sid: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateResponse {
    fn default() -> &'a CreateResponse {
        <CreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateResponse {
    pub fn new() -> CreateResponse {
        ::std::default::Default::default()
    }

    // repeated .medea.CreateResponse.SidEntry sid = 1;


    pub fn get_sid(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.sid
    }
    pub fn clear_sid(&mut self) {
        self.sid.clear();
    }

    // Param is passed by value, moved
    pub fn set_sid(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.sid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sid(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.sid
    }

    // Take field
    pub fn take_sid(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.sid, ::std::collections::HashMap::new())
    }

    // .medea.Error error = 2;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for CreateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.sid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.sid);
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.sid, os)?;
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateResponse {
        CreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "sid",
                    |m: &CreateResponse| { &m.sid },
                    |m: &mut CreateResponse| { &mut m.sid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "error",
                    |m: &CreateResponse| { &m.error },
                    |m: &mut CreateResponse| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateResponse>(
                    "CreateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateResponse,
        };
        unsafe {
            instance.get(CreateResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateResponse {
    fn clear(&mut self) {
        self.sid.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetResponse {
    // message fields
    pub elements: ::std::collections::HashMap<::std::string::String, Element>,
    pub error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetResponse {
    fn default() -> &'a GetResponse {
        <GetResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetResponse {
    pub fn new() -> GetResponse {
        ::std::default::Default::default()
    }

    // repeated .medea.GetResponse.ElementsEntry elements = 1;


    pub fn get_elements(&self) -> &::std::collections::HashMap<::std::string::String, Element> {
        &self.elements
    }
    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::std::collections::HashMap<::std::string::String, Element>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, Element> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::std::collections::HashMap<::std::string::String, Element> {
        ::std::mem::replace(&mut self.elements, ::std::collections::HashMap::new())
    }

    // .medea.Error error = 2;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for GetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Element>>(wire_type, is, &mut self.elements)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Element>>(1, &self.elements);
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Element>>(1, &self.elements, os)?;
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetResponse {
        GetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Element>>(
                    "elements",
                    |m: &GetResponse| { &m.elements },
                    |m: &mut GetResponse| { &mut m.elements },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "error",
                    |m: &GetResponse| { &m.error },
                    |m: &mut GetResponse| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetResponse>(
                    "GetResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetResponse,
        };
        unsafe {
            instance.get(GetResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetResponse {
    fn clear(&mut self) {
        self.elements.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Error {
    // message fields
    pub code: u32,
    pub text: ::std::string::String,
    pub doc: ::std::string::String,
    pub element: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // uint32 code = 1;


    pub fn get_code(&self) -> u32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: u32) {
        self.code = v;
    }

    // string text = 2;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }

    // string doc = 3;


    pub fn get_doc(&self) -> &str {
        &self.doc
    }
    pub fn clear_doc(&mut self) {
        self.doc.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc(&mut self, v: ::std::string::String) {
        self.doc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc(&mut self) -> &mut ::std::string::String {
        &mut self.doc
    }

    // Take field
    pub fn take_doc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc, ::std::string::String::new())
    }

    // string element = 4;


    pub fn get_element(&self) -> &str {
        &self.element
    }
    pub fn clear_element(&mut self) {
        self.element.clear();
    }

    // Param is passed by value, moved
    pub fn set_element(&mut self, v: ::std::string::String) {
        self.element = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element(&mut self) -> &mut ::std::string::String {
        &mut self.element
    }

    // Take field
    pub fn take_element(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.element, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.element)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.text);
        }
        if !self.doc.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.doc);
        }
        if !self.element.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.element);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_uint32(1, self.code)?;
        }
        if !self.text.is_empty() {
            os.write_string(2, &self.text)?;
        }
        if !self.doc.is_empty() {
            os.write_string(3, &self.doc)?;
        }
        if !self.element.is_empty() {
            os.write_string(4, &self.element)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "code",
                    |m: &Error| { &m.code },
                    |m: &mut Error| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &Error| { &m.text },
                    |m: &mut Error| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "doc",
                    |m: &Error| { &m.doc },
                    |m: &mut Error| { &mut m.doc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "element",
                    |m: &Error| { &m.element },
                    |m: &mut Error| { &mut m.element },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Error>(
                    "Error",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Error {
        static mut instance: ::protobuf::lazy::Lazy<Error> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Error,
        };
        unsafe {
            instance.get(Error::new)
        }
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.code = 0;
        self.text.clear();
        self.doc.clear();
        self.element.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Element {
    // message oneof groups
    pub el: ::std::option::Option<Element_oneof_el>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Element {
    fn default() -> &'a Element {
        <Element as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Element_oneof_el {
    member(Member),
    room(Room),
    webrtc_play(WebRtcPlayEndpoint),
    webrtc_pub(WebRtcPublishEndpoint),
}

impl Element {
    pub fn new() -> Element {
        ::std::default::Default::default()
    }

    // .medea.Member member = 1;


    pub fn get_member(&self) -> &Member {
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::member(ref v)) => v,
            _ => Member::default_instance(),
        }
    }
    pub fn clear_member(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_member(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::member(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: Member) {
        self.el = ::std::option::Option::Some(Element_oneof_el::member(v))
    }

    // Mutable pointer to the field.
    pub fn mut_member(&mut self) -> &mut Member {
        if let ::std::option::Option::Some(Element_oneof_el::member(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(Element_oneof_el::member(Member::new()));
        }
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::member(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_member(&mut self) -> Member {
        if self.has_member() {
            match self.el.take() {
                ::std::option::Option::Some(Element_oneof_el::member(v)) => v,
                _ => panic!(),
            }
        } else {
            Member::new()
        }
    }

    // .medea.Room room = 2;


    pub fn get_room(&self) -> &Room {
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::room(ref v)) => v,
            _ => Room::default_instance(),
        }
    }
    pub fn clear_room(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_room(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::room(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_room(&mut self, v: Room) {
        self.el = ::std::option::Option::Some(Element_oneof_el::room(v))
    }

    // Mutable pointer to the field.
    pub fn mut_room(&mut self) -> &mut Room {
        if let ::std::option::Option::Some(Element_oneof_el::room(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(Element_oneof_el::room(Room::new()));
        }
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::room(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_room(&mut self) -> Room {
        if self.has_room() {
            match self.el.take() {
                ::std::option::Option::Some(Element_oneof_el::room(v)) => v,
                _ => panic!(),
            }
        } else {
            Room::new()
        }
    }

    // .medea.WebRtcPlayEndpoint webrtc_play = 3;


    pub fn get_webrtc_play(&self) -> &WebRtcPlayEndpoint {
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::webrtc_play(ref v)) => v,
            _ => WebRtcPlayEndpoint::default_instance(),
        }
    }
    pub fn clear_webrtc_play(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_webrtc_play(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::webrtc_play(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_webrtc_play(&mut self, v: WebRtcPlayEndpoint) {
        self.el = ::std::option::Option::Some(Element_oneof_el::webrtc_play(v))
    }

    // Mutable pointer to the field.
    pub fn mut_webrtc_play(&mut self) -> &mut WebRtcPlayEndpoint {
        if let ::std::option::Option::Some(Element_oneof_el::webrtc_play(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(Element_oneof_el::webrtc_play(WebRtcPlayEndpoint::new()));
        }
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::webrtc_play(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_webrtc_play(&mut self) -> WebRtcPlayEndpoint {
        if self.has_webrtc_play() {
            match self.el.take() {
                ::std::option::Option::Some(Element_oneof_el::webrtc_play(v)) => v,
                _ => panic!(),
            }
        } else {
            WebRtcPlayEndpoint::new()
        }
    }

    // .medea.WebRtcPublishEndpoint webrtc_pub = 4;


    pub fn get_webrtc_pub(&self) -> &WebRtcPublishEndpoint {
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::webrtc_pub(ref v)) => v,
            _ => WebRtcPublishEndpoint::default_instance(),
        }
    }
    pub fn clear_webrtc_pub(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_webrtc_pub(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::webrtc_pub(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_webrtc_pub(&mut self, v: WebRtcPublishEndpoint) {
        self.el = ::std::option::Option::Some(Element_oneof_el::webrtc_pub(v))
    }

    // Mutable pointer to the field.
    pub fn mut_webrtc_pub(&mut self) -> &mut WebRtcPublishEndpoint {
        if let ::std::option::Option::Some(Element_oneof_el::webrtc_pub(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(Element_oneof_el::webrtc_pub(WebRtcPublishEndpoint::new()));
        }
        match self.el {
            ::std::option::Option::Some(Element_oneof_el::webrtc_pub(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_webrtc_pub(&mut self) -> WebRtcPublishEndpoint {
        if self.has_webrtc_pub() {
            match self.el.take() {
                ::std::option::Option::Some(Element_oneof_el::webrtc_pub(v)) => v,
                _ => panic!(),
            }
        } else {
            WebRtcPublishEndpoint::new()
        }
    }
}

impl ::protobuf::Message for Element {
    fn is_initialized(&self) -> bool {
        if let Some(Element_oneof_el::member(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Element_oneof_el::room(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Element_oneof_el::webrtc_play(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Element_oneof_el::webrtc_pub(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(Element_oneof_el::member(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(Element_oneof_el::room(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(Element_oneof_el::webrtc_play(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(Element_oneof_el::webrtc_pub(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.el {
            match v {
                &Element_oneof_el::member(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Element_oneof_el::room(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Element_oneof_el::webrtc_play(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Element_oneof_el::webrtc_pub(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.el {
            match v {
                &Element_oneof_el::member(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Element_oneof_el::room(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Element_oneof_el::webrtc_play(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Element_oneof_el::webrtc_pub(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Element {
        Element::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Member>(
                    "member",
                    Element::has_member,
                    Element::get_member,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Room>(
                    "room",
                    Element::has_room,
                    Element::get_room,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WebRtcPlayEndpoint>(
                    "webrtc_play",
                    Element::has_webrtc_play,
                    Element::get_webrtc_play,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WebRtcPublishEndpoint>(
                    "webrtc_pub",
                    Element::has_webrtc_pub,
                    Element::get_webrtc_pub,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Element>(
                    "Element",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Element {
        static mut instance: ::protobuf::lazy::Lazy<Element> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Element,
        };
        unsafe {
            instance.get(Element::new)
        }
    }
}

impl ::protobuf::Clear for Element {
    fn clear(&mut self) {
        self.el = ::std::option::Option::None;
        self.el = ::std::option::Option::None;
        self.el = ::std::option::Option::None;
        self.el = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Element {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Element {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Room {
    // message fields
    pub id: ::std::string::String,
    pub pipeline: ::std::collections::HashMap<::std::string::String, Room_Element>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Room {
    fn default() -> &'a Room {
        <Room as ::protobuf::Message>::default_instance()
    }
}

impl Room {
    pub fn new() -> Room {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated .medea.Room.PipelineEntry pipeline = 2;


    pub fn get_pipeline(&self) -> &::std::collections::HashMap<::std::string::String, Room_Element> {
        &self.pipeline
    }
    pub fn clear_pipeline(&mut self) {
        self.pipeline.clear();
    }

    // Param is passed by value, moved
    pub fn set_pipeline(&mut self, v: ::std::collections::HashMap<::std::string::String, Room_Element>) {
        self.pipeline = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pipeline(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, Room_Element> {
        &mut self.pipeline
    }

    // Take field
    pub fn take_pipeline(&mut self) -> ::std::collections::HashMap<::std::string::String, Room_Element> {
        ::std::mem::replace(&mut self.pipeline, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Room {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Room_Element>>(wire_type, is, &mut self.pipeline)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Room_Element>>(2, &self.pipeline);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Room_Element>>(2, &self.pipeline, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Room {
        Room::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Room| { &m.id },
                    |m: &mut Room| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Room_Element>>(
                    "pipeline",
                    |m: &Room| { &m.pipeline },
                    |m: &mut Room| { &mut m.pipeline },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Room>(
                    "Room",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Room {
        static mut instance: ::protobuf::lazy::Lazy<Room> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Room,
        };
        unsafe {
            instance.get(Room::new)
        }
    }
}

impl ::protobuf::Clear for Room {
    fn clear(&mut self) {
        self.id.clear();
        self.pipeline.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Room {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Room {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Room_Element {
    // message oneof groups
    pub el: ::std::option::Option<Room_Element_oneof_el>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Room_Element {
    fn default() -> &'a Room_Element {
        <Room_Element as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Room_Element_oneof_el {
    member(Member),
    webrtc_play(WebRtcPlayEndpoint),
    webrtc_pub(WebRtcPublishEndpoint),
}

impl Room_Element {
    pub fn new() -> Room_Element {
        ::std::default::Default::default()
    }

    // .medea.Member member = 1;


    pub fn get_member(&self) -> &Member {
        match self.el {
            ::std::option::Option::Some(Room_Element_oneof_el::member(ref v)) => v,
            _ => Member::default_instance(),
        }
    }
    pub fn clear_member(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_member(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(Room_Element_oneof_el::member(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: Member) {
        self.el = ::std::option::Option::Some(Room_Element_oneof_el::member(v))
    }

    // Mutable pointer to the field.
    pub fn mut_member(&mut self) -> &mut Member {
        if let ::std::option::Option::Some(Room_Element_oneof_el::member(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(Room_Element_oneof_el::member(Member::new()));
        }
        match self.el {
            ::std::option::Option::Some(Room_Element_oneof_el::member(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_member(&mut self) -> Member {
        if self.has_member() {
            match self.el.take() {
                ::std::option::Option::Some(Room_Element_oneof_el::member(v)) => v,
                _ => panic!(),
            }
        } else {
            Member::new()
        }
    }

    // .medea.WebRtcPlayEndpoint webrtc_play = 2;


    pub fn get_webrtc_play(&self) -> &WebRtcPlayEndpoint {
        match self.el {
            ::std::option::Option::Some(Room_Element_oneof_el::webrtc_play(ref v)) => v,
            _ => WebRtcPlayEndpoint::default_instance(),
        }
    }
    pub fn clear_webrtc_play(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_webrtc_play(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(Room_Element_oneof_el::webrtc_play(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_webrtc_play(&mut self, v: WebRtcPlayEndpoint) {
        self.el = ::std::option::Option::Some(Room_Element_oneof_el::webrtc_play(v))
    }

    // Mutable pointer to the field.
    pub fn mut_webrtc_play(&mut self) -> &mut WebRtcPlayEndpoint {
        if let ::std::option::Option::Some(Room_Element_oneof_el::webrtc_play(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(Room_Element_oneof_el::webrtc_play(WebRtcPlayEndpoint::new()));
        }
        match self.el {
            ::std::option::Option::Some(Room_Element_oneof_el::webrtc_play(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_webrtc_play(&mut self) -> WebRtcPlayEndpoint {
        if self.has_webrtc_play() {
            match self.el.take() {
                ::std::option::Option::Some(Room_Element_oneof_el::webrtc_play(v)) => v,
                _ => panic!(),
            }
        } else {
            WebRtcPlayEndpoint::new()
        }
    }

    // .medea.WebRtcPublishEndpoint webrtc_pub = 3;


    pub fn get_webrtc_pub(&self) -> &WebRtcPublishEndpoint {
        match self.el {
            ::std::option::Option::Some(Room_Element_oneof_el::webrtc_pub(ref v)) => v,
            _ => WebRtcPublishEndpoint::default_instance(),
        }
    }
    pub fn clear_webrtc_pub(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_webrtc_pub(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(Room_Element_oneof_el::webrtc_pub(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_webrtc_pub(&mut self, v: WebRtcPublishEndpoint) {
        self.el = ::std::option::Option::Some(Room_Element_oneof_el::webrtc_pub(v))
    }

    // Mutable pointer to the field.
    pub fn mut_webrtc_pub(&mut self) -> &mut WebRtcPublishEndpoint {
        if let ::std::option::Option::Some(Room_Element_oneof_el::webrtc_pub(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(Room_Element_oneof_el::webrtc_pub(WebRtcPublishEndpoint::new()));
        }
        match self.el {
            ::std::option::Option::Some(Room_Element_oneof_el::webrtc_pub(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_webrtc_pub(&mut self) -> WebRtcPublishEndpoint {
        if self.has_webrtc_pub() {
            match self.el.take() {
                ::std::option::Option::Some(Room_Element_oneof_el::webrtc_pub(v)) => v,
                _ => panic!(),
            }
        } else {
            WebRtcPublishEndpoint::new()
        }
    }
}

impl ::protobuf::Message for Room_Element {
    fn is_initialized(&self) -> bool {
        if let Some(Room_Element_oneof_el::member(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Room_Element_oneof_el::webrtc_play(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Room_Element_oneof_el::webrtc_pub(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(Room_Element_oneof_el::member(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(Room_Element_oneof_el::webrtc_play(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(Room_Element_oneof_el::webrtc_pub(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.el {
            match v {
                &Room_Element_oneof_el::member(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Room_Element_oneof_el::webrtc_play(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Room_Element_oneof_el::webrtc_pub(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.el {
            match v {
                &Room_Element_oneof_el::member(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Room_Element_oneof_el::webrtc_play(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Room_Element_oneof_el::webrtc_pub(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Room_Element {
        Room_Element::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Member>(
                    "member",
                    Room_Element::has_member,
                    Room_Element::get_member,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WebRtcPlayEndpoint>(
                    "webrtc_play",
                    Room_Element::has_webrtc_play,
                    Room_Element::get_webrtc_play,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WebRtcPublishEndpoint>(
                    "webrtc_pub",
                    Room_Element::has_webrtc_pub,
                    Room_Element::get_webrtc_pub,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Room_Element>(
                    "Room_Element",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Room_Element {
        static mut instance: ::protobuf::lazy::Lazy<Room_Element> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Room_Element,
        };
        unsafe {
            instance.get(Room_Element::new)
        }
    }
}

impl ::protobuf::Clear for Room_Element {
    fn clear(&mut self) {
        self.el = ::std::option::Option::None;
        self.el = ::std::option::Option::None;
        self.el = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Room_Element {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Room_Element {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Member {
    // message fields
    pub id: ::std::string::String,
    pub on_join: ::std::string::String,
    pub on_leave: ::std::string::String,
    pub credentials: ::std::string::String,
    pub pipeline: ::std::collections::HashMap<::std::string::String, Member_Element>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Member {
    fn default() -> &'a Member {
        <Member as ::protobuf::Message>::default_instance()
    }
}

impl Member {
    pub fn new() -> Member {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string on_join = 2;


    pub fn get_on_join(&self) -> &str {
        &self.on_join
    }
    pub fn clear_on_join(&mut self) {
        self.on_join.clear();
    }

    // Param is passed by value, moved
    pub fn set_on_join(&mut self, v: ::std::string::String) {
        self.on_join = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_on_join(&mut self) -> &mut ::std::string::String {
        &mut self.on_join
    }

    // Take field
    pub fn take_on_join(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.on_join, ::std::string::String::new())
    }

    // string on_leave = 3;


    pub fn get_on_leave(&self) -> &str {
        &self.on_leave
    }
    pub fn clear_on_leave(&mut self) {
        self.on_leave.clear();
    }

    // Param is passed by value, moved
    pub fn set_on_leave(&mut self, v: ::std::string::String) {
        self.on_leave = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_on_leave(&mut self) -> &mut ::std::string::String {
        &mut self.on_leave
    }

    // Take field
    pub fn take_on_leave(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.on_leave, ::std::string::String::new())
    }

    // string credentials = 4;


    pub fn get_credentials(&self) -> &str {
        &self.credentials
    }
    pub fn clear_credentials(&mut self) {
        self.credentials.clear();
    }

    // Param is passed by value, moved
    pub fn set_credentials(&mut self, v: ::std::string::String) {
        self.credentials = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credentials(&mut self) -> &mut ::std::string::String {
        &mut self.credentials
    }

    // Take field
    pub fn take_credentials(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.credentials, ::std::string::String::new())
    }

    // repeated .medea.Member.PipelineEntry pipeline = 5;


    pub fn get_pipeline(&self) -> &::std::collections::HashMap<::std::string::String, Member_Element> {
        &self.pipeline
    }
    pub fn clear_pipeline(&mut self) {
        self.pipeline.clear();
    }

    // Param is passed by value, moved
    pub fn set_pipeline(&mut self, v: ::std::collections::HashMap<::std::string::String, Member_Element>) {
        self.pipeline = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pipeline(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, Member_Element> {
        &mut self.pipeline
    }

    // Take field
    pub fn take_pipeline(&mut self) -> ::std::collections::HashMap<::std::string::String, Member_Element> {
        ::std::mem::replace(&mut self.pipeline, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.on_join)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.on_leave)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.credentials)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Member_Element>>(wire_type, is, &mut self.pipeline)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.on_join.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.on_join);
        }
        if !self.on_leave.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.on_leave);
        }
        if !self.credentials.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.credentials);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Member_Element>>(5, &self.pipeline);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.on_join.is_empty() {
            os.write_string(2, &self.on_join)?;
        }
        if !self.on_leave.is_empty() {
            os.write_string(3, &self.on_leave)?;
        }
        if !self.credentials.is_empty() {
            os.write_string(4, &self.credentials)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Member_Element>>(5, &self.pipeline, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Member {
        Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Member| { &m.id },
                    |m: &mut Member| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "on_join",
                    |m: &Member| { &m.on_join },
                    |m: &mut Member| { &mut m.on_join },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "on_leave",
                    |m: &Member| { &m.on_leave },
                    |m: &mut Member| { &mut m.on_leave },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "credentials",
                    |m: &Member| { &m.credentials },
                    |m: &mut Member| { &mut m.credentials },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Member_Element>>(
                    "pipeline",
                    |m: &Member| { &m.pipeline },
                    |m: &mut Member| { &mut m.pipeline },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Member>(
                    "Member",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Member {
        static mut instance: ::protobuf::lazy::Lazy<Member> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Member,
        };
        unsafe {
            instance.get(Member::new)
        }
    }
}

impl ::protobuf::Clear for Member {
    fn clear(&mut self) {
        self.id.clear();
        self.on_join.clear();
        self.on_leave.clear();
        self.credentials.clear();
        self.pipeline.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Member {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Member_Element {
    // message oneof groups
    pub el: ::std::option::Option<Member_Element_oneof_el>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Member_Element {
    fn default() -> &'a Member_Element {
        <Member_Element as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Member_Element_oneof_el {
    webrtc_play(WebRtcPlayEndpoint),
    webrtc_pub(WebRtcPublishEndpoint),
}

impl Member_Element {
    pub fn new() -> Member_Element {
        ::std::default::Default::default()
    }

    // .medea.WebRtcPlayEndpoint webrtc_play = 1;


    pub fn get_webrtc_play(&self) -> &WebRtcPlayEndpoint {
        match self.el {
            ::std::option::Option::Some(Member_Element_oneof_el::webrtc_play(ref v)) => v,
            _ => WebRtcPlayEndpoint::default_instance(),
        }
    }
    pub fn clear_webrtc_play(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_webrtc_play(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(Member_Element_oneof_el::webrtc_play(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_webrtc_play(&mut self, v: WebRtcPlayEndpoint) {
        self.el = ::std::option::Option::Some(Member_Element_oneof_el::webrtc_play(v))
    }

    // Mutable pointer to the field.
    pub fn mut_webrtc_play(&mut self) -> &mut WebRtcPlayEndpoint {
        if let ::std::option::Option::Some(Member_Element_oneof_el::webrtc_play(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(Member_Element_oneof_el::webrtc_play(WebRtcPlayEndpoint::new()));
        }
        match self.el {
            ::std::option::Option::Some(Member_Element_oneof_el::webrtc_play(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_webrtc_play(&mut self) -> WebRtcPlayEndpoint {
        if self.has_webrtc_play() {
            match self.el.take() {
                ::std::option::Option::Some(Member_Element_oneof_el::webrtc_play(v)) => v,
                _ => panic!(),
            }
        } else {
            WebRtcPlayEndpoint::new()
        }
    }

    // .medea.WebRtcPublishEndpoint webrtc_pub = 2;


    pub fn get_webrtc_pub(&self) -> &WebRtcPublishEndpoint {
        match self.el {
            ::std::option::Option::Some(Member_Element_oneof_el::webrtc_pub(ref v)) => v,
            _ => WebRtcPublishEndpoint::default_instance(),
        }
    }
    pub fn clear_webrtc_pub(&mut self) {
        self.el = ::std::option::Option::None;
    }

    pub fn has_webrtc_pub(&self) -> bool {
        match self.el {
            ::std::option::Option::Some(Member_Element_oneof_el::webrtc_pub(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_webrtc_pub(&mut self, v: WebRtcPublishEndpoint) {
        self.el = ::std::option::Option::Some(Member_Element_oneof_el::webrtc_pub(v))
    }

    // Mutable pointer to the field.
    pub fn mut_webrtc_pub(&mut self) -> &mut WebRtcPublishEndpoint {
        if let ::std::option::Option::Some(Member_Element_oneof_el::webrtc_pub(_)) = self.el {
        } else {
            self.el = ::std::option::Option::Some(Member_Element_oneof_el::webrtc_pub(WebRtcPublishEndpoint::new()));
        }
        match self.el {
            ::std::option::Option::Some(Member_Element_oneof_el::webrtc_pub(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_webrtc_pub(&mut self) -> WebRtcPublishEndpoint {
        if self.has_webrtc_pub() {
            match self.el.take() {
                ::std::option::Option::Some(Member_Element_oneof_el::webrtc_pub(v)) => v,
                _ => panic!(),
            }
        } else {
            WebRtcPublishEndpoint::new()
        }
    }
}

impl ::protobuf::Message for Member_Element {
    fn is_initialized(&self) -> bool {
        if let Some(Member_Element_oneof_el::webrtc_play(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Member_Element_oneof_el::webrtc_pub(ref v)) = self.el {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(Member_Element_oneof_el::webrtc_play(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.el = ::std::option::Option::Some(Member_Element_oneof_el::webrtc_pub(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.el {
            match v {
                &Member_Element_oneof_el::webrtc_play(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Member_Element_oneof_el::webrtc_pub(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.el {
            match v {
                &Member_Element_oneof_el::webrtc_play(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Member_Element_oneof_el::webrtc_pub(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Member_Element {
        Member_Element::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WebRtcPlayEndpoint>(
                    "webrtc_play",
                    Member_Element::has_webrtc_play,
                    Member_Element::get_webrtc_play,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WebRtcPublishEndpoint>(
                    "webrtc_pub",
                    Member_Element::has_webrtc_pub,
                    Member_Element::get_webrtc_pub,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Member_Element>(
                    "Member_Element",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Member_Element {
        static mut instance: ::protobuf::lazy::Lazy<Member_Element> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Member_Element,
        };
        unsafe {
            instance.get(Member_Element::new)
        }
    }
}

impl ::protobuf::Clear for Member_Element {
    fn clear(&mut self) {
        self.el = ::std::option::Option::None;
        self.el = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Member_Element {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Member_Element {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WebRtcPublishEndpoint {
    // message fields
    pub id: ::std::string::String,
    pub p2p: WebRtcPublishEndpoint_P2P,
    pub on_start: ::std::string::String,
    pub on_stop: ::std::string::String,
    pub is_relay: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebRtcPublishEndpoint {
    fn default() -> &'a WebRtcPublishEndpoint {
        <WebRtcPublishEndpoint as ::protobuf::Message>::default_instance()
    }
}

impl WebRtcPublishEndpoint {
    pub fn new() -> WebRtcPublishEndpoint {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .medea.WebRtcPublishEndpoint.P2P p2p = 2;


    pub fn get_p2p(&self) -> WebRtcPublishEndpoint_P2P {
        self.p2p
    }
    pub fn clear_p2p(&mut self) {
        self.p2p = WebRtcPublishEndpoint_P2P::NEVER;
    }

    // Param is passed by value, moved
    pub fn set_p2p(&mut self, v: WebRtcPublishEndpoint_P2P) {
        self.p2p = v;
    }

    // string on_start = 3;


    pub fn get_on_start(&self) -> &str {
        &self.on_start
    }
    pub fn clear_on_start(&mut self) {
        self.on_start.clear();
    }

    // Param is passed by value, moved
    pub fn set_on_start(&mut self, v: ::std::string::String) {
        self.on_start = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_on_start(&mut self) -> &mut ::std::string::String {
        &mut self.on_start
    }

    // Take field
    pub fn take_on_start(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.on_start, ::std::string::String::new())
    }

    // string on_stop = 4;


    pub fn get_on_stop(&self) -> &str {
        &self.on_stop
    }
    pub fn clear_on_stop(&mut self) {
        self.on_stop.clear();
    }

    // Param is passed by value, moved
    pub fn set_on_stop(&mut self, v: ::std::string::String) {
        self.on_stop = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_on_stop(&mut self) -> &mut ::std::string::String {
        &mut self.on_stop
    }

    // Take field
    pub fn take_on_stop(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.on_stop, ::std::string::String::new())
    }

    // bool is_relay = 5;


    pub fn get_is_relay(&self) -> bool {
        self.is_relay
    }
    pub fn clear_is_relay(&mut self) {
        self.is_relay = false;
    }

    // Param is passed by value, moved
    pub fn set_is_relay(&mut self, v: bool) {
        self.is_relay = v;
    }
}

impl ::protobuf::Message for WebRtcPublishEndpoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.p2p, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.on_start)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.on_stop)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_relay = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.p2p != WebRtcPublishEndpoint_P2P::NEVER {
            my_size += ::protobuf::rt::enum_size(2, self.p2p);
        }
        if !self.on_start.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.on_start);
        }
        if !self.on_stop.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.on_stop);
        }
        if self.is_relay != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.p2p != WebRtcPublishEndpoint_P2P::NEVER {
            os.write_enum(2, self.p2p.value())?;
        }
        if !self.on_start.is_empty() {
            os.write_string(3, &self.on_start)?;
        }
        if !self.on_stop.is_empty() {
            os.write_string(4, &self.on_stop)?;
        }
        if self.is_relay != false {
            os.write_bool(5, self.is_relay)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebRtcPublishEndpoint {
        WebRtcPublishEndpoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &WebRtcPublishEndpoint| { &m.id },
                    |m: &mut WebRtcPublishEndpoint| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WebRtcPublishEndpoint_P2P>>(
                    "p2p",
                    |m: &WebRtcPublishEndpoint| { &m.p2p },
                    |m: &mut WebRtcPublishEndpoint| { &mut m.p2p },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "on_start",
                    |m: &WebRtcPublishEndpoint| { &m.on_start },
                    |m: &mut WebRtcPublishEndpoint| { &mut m.on_start },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "on_stop",
                    |m: &WebRtcPublishEndpoint| { &m.on_stop },
                    |m: &mut WebRtcPublishEndpoint| { &mut m.on_stop },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_relay",
                    |m: &WebRtcPublishEndpoint| { &m.is_relay },
                    |m: &mut WebRtcPublishEndpoint| { &mut m.is_relay },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WebRtcPublishEndpoint>(
                    "WebRtcPublishEndpoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WebRtcPublishEndpoint {
        static mut instance: ::protobuf::lazy::Lazy<WebRtcPublishEndpoint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WebRtcPublishEndpoint,
        };
        unsafe {
            instance.get(WebRtcPublishEndpoint::new)
        }
    }
}

impl ::protobuf::Clear for WebRtcPublishEndpoint {
    fn clear(&mut self) {
        self.id.clear();
        self.p2p = WebRtcPublishEndpoint_P2P::NEVER;
        self.on_start.clear();
        self.on_stop.clear();
        self.is_relay = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WebRtcPublishEndpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRtcPublishEndpoint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WebRtcPublishEndpoint_P2P {
    NEVER = 0,
    IF_POSSIBLE = 1,
    ALWAYS = 2,
}

impl ::protobuf::ProtobufEnum for WebRtcPublishEndpoint_P2P {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WebRtcPublishEndpoint_P2P> {
        match value {
            0 => ::std::option::Option::Some(WebRtcPublishEndpoint_P2P::NEVER),
            1 => ::std::option::Option::Some(WebRtcPublishEndpoint_P2P::IF_POSSIBLE),
            2 => ::std::option::Option::Some(WebRtcPublishEndpoint_P2P::ALWAYS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WebRtcPublishEndpoint_P2P] = &[
            WebRtcPublishEndpoint_P2P::NEVER,
            WebRtcPublishEndpoint_P2P::IF_POSSIBLE,
            WebRtcPublishEndpoint_P2P::ALWAYS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("WebRtcPublishEndpoint_P2P", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WebRtcPublishEndpoint_P2P {
}

impl ::std::default::Default for WebRtcPublishEndpoint_P2P {
    fn default() -> Self {
        WebRtcPublishEndpoint_P2P::NEVER
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRtcPublishEndpoint_P2P {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WebRtcPlayEndpoint {
    // message fields
    pub id: ::std::string::String,
    pub src: ::std::string::String,
    pub on_start: ::std::string::String,
    pub on_stop: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebRtcPlayEndpoint {
    fn default() -> &'a WebRtcPlayEndpoint {
        <WebRtcPlayEndpoint as ::protobuf::Message>::default_instance()
    }
}

impl WebRtcPlayEndpoint {
    pub fn new() -> WebRtcPlayEndpoint {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string src = 2;


    pub fn get_src(&self) -> &str {
        &self.src
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        &mut self.src
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src, ::std::string::String::new())
    }

    // string on_start = 3;


    pub fn get_on_start(&self) -> &str {
        &self.on_start
    }
    pub fn clear_on_start(&mut self) {
        self.on_start.clear();
    }

    // Param is passed by value, moved
    pub fn set_on_start(&mut self, v: ::std::string::String) {
        self.on_start = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_on_start(&mut self) -> &mut ::std::string::String {
        &mut self.on_start
    }

    // Take field
    pub fn take_on_start(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.on_start, ::std::string::String::new())
    }

    // string on_stop = 4;


    pub fn get_on_stop(&self) -> &str {
        &self.on_stop
    }
    pub fn clear_on_stop(&mut self) {
        self.on_stop.clear();
    }

    // Param is passed by value, moved
    pub fn set_on_stop(&mut self, v: ::std::string::String) {
        self.on_stop = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_on_stop(&mut self) -> &mut ::std::string::String {
        &mut self.on_stop
    }

    // Take field
    pub fn take_on_stop(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.on_stop, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WebRtcPlayEndpoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.on_start)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.on_stop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.src.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.src);
        }
        if !self.on_start.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.on_start);
        }
        if !self.on_stop.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.on_stop);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.src.is_empty() {
            os.write_string(2, &self.src)?;
        }
        if !self.on_start.is_empty() {
            os.write_string(3, &self.on_start)?;
        }
        if !self.on_stop.is_empty() {
            os.write_string(4, &self.on_stop)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebRtcPlayEndpoint {
        WebRtcPlayEndpoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &WebRtcPlayEndpoint| { &m.id },
                    |m: &mut WebRtcPlayEndpoint| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &WebRtcPlayEndpoint| { &m.src },
                    |m: &mut WebRtcPlayEndpoint| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "on_start",
                    |m: &WebRtcPlayEndpoint| { &m.on_start },
                    |m: &mut WebRtcPlayEndpoint| { &mut m.on_start },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "on_stop",
                    |m: &WebRtcPlayEndpoint| { &m.on_stop },
                    |m: &mut WebRtcPlayEndpoint| { &mut m.on_stop },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WebRtcPlayEndpoint>(
                    "WebRtcPlayEndpoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WebRtcPlayEndpoint {
        static mut instance: ::protobuf::lazy::Lazy<WebRtcPlayEndpoint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WebRtcPlayEndpoint,
        };
        unsafe {
            instance.get(WebRtcPlayEndpoint::new)
        }
    }
}

impl ::protobuf::Clear for WebRtcPlayEndpoint {
    fn clear(&mut self) {
        self.id.clear();
        self.src.clear();
        self.on_start.clear();
        self.on_stop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WebRtcPlayEndpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebRtcPlayEndpoint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tapi.proto\x12\x05medea\"\xfd\x01\n\rCreateRequest\x12\x1d\n\nparent_\
    fid\x18\x01\x20\x01(\tR\tparentFid\x12'\n\x06member\x18\x02\x20\x01(\x0b\
    2\r.medea.MemberH\0R\x06member\x12!\n\x04room\x18\x03\x20\x01(\x0b2\x0b.\
    medea.RoomH\0R\x04room\x12<\n\x0bwebrtc_play\x18\x04\x20\x01(\x0b2\x19.m\
    edea.WebRtcPlayEndpointH\0R\nwebrtcPlay\x12=\n\nwebrtc_pub\x18\x05\x20\
    \x01(\x0b2\x1c.medea.WebRtcPublishEndpointH\0R\twebrtcPubB\x04\n\x02el\"\
    \x1d\n\tIdRequest\x12\x10\n\x03fid\x18\x01\x20\x03(\tR\x03fid\".\n\x08Re\
    sponse\x12\"\n\x05error\x18\x01\x20\x01(\x0b2\x0c.medea.ErrorR\x05error\
    \"\x9e\x01\n\x0eCreateResponse\x120\n\x03sid\x18\x01\x20\x03(\x0b2\x1e.m\
    edea.CreateResponse.SidEntryR\x03sid\x12\"\n\x05error\x18\x02\x20\x01(\
    \x0b2\x0c.medea.ErrorR\x05error\x1a6\n\x08SidEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\"\xbc\x01\n\x0bGetResponse\x12<\n\x08elements\x18\x01\x20\x03(\
    \x0b2\x20.medea.GetResponse.ElementsEntryR\x08elements\x12\"\n\x05error\
    \x18\x02\x20\x01(\x0b2\x0c.medea.ErrorR\x05error\x1aK\n\rElementsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12$\n\x05value\x18\x02\x20\
    \x01(\x0b2\x0e.medea.ElementR\x05value:\x028\x01\"[\n\x05Error\x12\x12\n\
    \x04code\x18\x01\x20\x01(\rR\x04code\x12\x12\n\x04text\x18\x02\x20\x01(\
    \tR\x04text\x12\x10\n\x03doc\x18\x03\x20\x01(\tR\x03doc\x12\x18\n\x07ele\
    ment\x18\x04\x20\x01(\tR\x07element\"\xd8\x01\n\x07Element\x12'\n\x06mem\
    ber\x18\x01\x20\x01(\x0b2\r.medea.MemberH\0R\x06member\x12!\n\x04room\
    \x18\x02\x20\x01(\x0b2\x0b.medea.RoomH\0R\x04room\x12<\n\x0bwebrtc_play\
    \x18\x03\x20\x01(\x0b2\x19.medea.WebRtcPlayEndpointH\0R\nwebrtcPlay\x12=\
    \n\nwebrtc_pub\x18\x04\x20\x01(\x0b2\x1c.medea.WebRtcPublishEndpointH\0R\
    \twebrtcPubB\x04\n\x02el\"\xd7\x02\n\x04Room\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x125\n\x08pipeline\x18\x02\x20\x03(\x0b2\x19.medea.Room.P\
    ipelineEntryR\x08pipeline\x1aP\n\rPipelineEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12)\n\x05value\x18\x02\x20\x01(\x0b2\x13.medea.Room\
    .ElementR\x05value:\x028\x01\x1a\xb5\x01\n\x07Element\x12'\n\x06member\
    \x18\x01\x20\x01(\x0b2\r.medea.MemberH\0R\x06member\x12<\n\x0bwebrtc_pla\
    y\x18\x02\x20\x01(\x0b2\x19.medea.WebRtcPlayEndpointH\0R\nwebrtcPlay\x12\
    =\n\nwebrtc_pub\x18\x03\x20\x01(\x0b2\x1c.medea.WebRtcPublishEndpointH\0\
    R\twebrtcPubB\x04\n\x02el\"\x8a\x03\n\x06Member\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x17\n\x07on_join\x18\x02\x20\x01(\tR\x06onJoin\
    \x12\x19\n\x08on_leave\x18\x03\x20\x01(\tR\x07onLeave\x12\x20\n\x0bcrede\
    ntials\x18\x04\x20\x01(\tR\x0bcredentials\x127\n\x08pipeline\x18\x05\x20\
    \x03(\x0b2\x1b.medea.Member.PipelineEntryR\x08pipeline\x1aR\n\rPipelineE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12+\n\x05value\x18\x02\
    \x20\x01(\x0b2\x15.medea.Member.ElementR\x05value:\x028\x01\x1a\x8c\x01\
    \n\x07Element\x12<\n\x0bwebrtc_play\x18\x01\x20\x01(\x0b2\x19.medea.WebR\
    tcPlayEndpointH\0R\nwebrtcPlay\x12=\n\nwebrtc_pub\x18\x02\x20\x01(\x0b2\
    \x1c.medea.WebRtcPublishEndpointH\0R\twebrtcPubB\x04\n\x02el\"\xd9\x01\n\
    \x15WebRtcPublishEndpoint\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x122\
    \n\x03p2p\x18\x02\x20\x01(\x0e2\x20.medea.WebRtcPublishEndpoint.P2PR\x03\
    p2p\x12\x19\n\x08on_start\x18\x03\x20\x01(\tR\x07onStart\x12\x17\n\x07on\
    _stop\x18\x04\x20\x01(\tR\x06onStop\x12\x19\n\x08is_relay\x18\x05\x20\
    \x01(\x08R\x07isRelay\"-\n\x03P2P\x12\t\n\x05NEVER\x10\0\x12\x0f\n\x0bIF\
    _POSSIBLE\x10\x01\x12\n\n\x06ALWAYS\x10\x02\"j\n\x12WebRtcPlayEndpoint\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x10\n\x03src\x18\x02\x20\
    \x01(\tR\x03src\x12\x19\n\x08on_start\x18\x03\x20\x01(\tR\x07onStart\x12\
    \x17\n\x07on_stop\x18\x04\x20\x01(\tR\x06onStop2\x9d\x01\n\nControlApi\
    \x125\n\x06Create\x12\x14.medea.CreateRequest\x1a\x15.medea.CreateRespon\
    se\x12+\n\x06Delete\x12\x10.medea.IdRequest\x1a\x0f.medea.Response\x12+\
    \n\x03Get\x12\x10.medea.IdRequest\x1a\x12.medea.GetResponseb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
