<!DOCTYPE html>
<html>
<head>
  <title>Chat</title>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.0/axios.min.js" integrity="sha384-6woDBwQr+eqsszpfCWmyJ2UTm+OSym/GuB2NAD8H3d+6xuEZzOMJ/6GEPDTPPCmi" crossorigin="anonymous"></script>
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <script type="module">
    import init, {
      Jason,
      MediaStreamSettings,
      AudioTrackConstraints,
      DeviceVideoTrackConstraints,
      DisplayVideoTrackConstraints,
    } from './js/medea_jason.js';

    const controlUrl = document.location.protocol + "//" +
                       document.location.host + "/control-api/";
    const userNameCookieName = "MEDEA_DEMO_USER_NAME";

    let chooseRoomDiv = document.getElementById('choose-room');
    let videoCallDiv = document.getElementById('video-call');
    let chooseRoomButton = document.getElementById('choose-room__join');
    let roomIdInput = document.getElementById('choose-room__room-id');
    let controlBtns = document.getElementById('control');
    let audioSelect = document.getElementById('connect__select-device_audio');
    let videoSelect = document.getElementById('connect__select-device_video');
    let localVideo = document.getElementById('local-video__video');
    let isForceRelayCheckbox = document.getElementById("is_force_relay");
    let isAudioEnabledCheckbox = document.getElementById('is-audio-enabled');
    let isVideoEnabledCheckbox = document.getElementById('is-video-enabled');
    let isPublishingEnabledCheckbox = document.getElementById('is-publishing-enabled');
    let usernameInput = document.getElementById('join__username');
    let muteAudioBtn = document.getElementById('control__mute_audio');
    let muteVideoBtn = document.getElementById('control__mute_video');
    let joinCallerButton = document.getElementById('join__join');
    let connectionState = document.getElementById('connection-state__state');
    let videoDiv = document.getElementById("remote-videos");
    let connectBtnsDiv = document.getElementById("join__join");
    let logsTextArea = document.getElementById("logs-output");

    let jason = null;
    let room = null;

    let isForceRelay = false;
    let localStream = null;
    let audioPublishPolicy = 'Optional';
    let videoPublishPolicy = 'Optional';
    let isCallStarted = false;
    let isJoinedRoom = false;
    let isAudioMuted = false;
    let isVideoMuted = false;
    let isPublishingEnabled = true;
    let remote_videos = {};

    async function createRoom(roomId) {
      try {
        await axios({
          method: 'post',
          url: controlUrl + roomId,
          data: {
            kind: 'Room',
            pipeline: {},
          },
        });
      } catch (e) {
        console.log(e.response);
      }
    }

    async function startPublishing(roomId, memberId) {
      await axios({
        method: 'post',
        url: controlUrl + roomId + "/" + memberId + '/publish',
        data: {
          kind: 'WebRtcPublishEndpoint',
          p2p: 'Always',
          force_relay: isForceRelay,
          audio_settings: {
            publish_policy: audioPublishPolicy,
          },
          video_settings: {
            publish_policy: videoPublishPolicy,
          },
        },
      });
      await startPublishPlaying(roomId, memberId);
    }

    async function stopPublishing(roomId, memberId) {
      await axios({
        method: 'delete',
        url: controlUrl + roomId + "/" + memberId + '/publish',
      });
      await stopPublishPlaying(roomId, memberId);
    }

    async function stopPublishPlaying(roomId, memberId) {
      let controlRoom = await axios.get(controlUrl + roomId);
      var otherMembers = Object.keys(controlRoom.data.element.pipeline);
      var deleteRequests = [];
      for (let i = 0; i < otherMembers.length; i++) {
        let id = otherMembers[i];

        if (id === memberId) {
          continue;
        }

        let deleteRequest = axios({
          method: 'delete',
          url: controlUrl + roomId + "/" + id + '/play-' + memberId,
        });
        deleteRequests.push(deleteRequest);
      }
      await Promise.all(deleteRequests);
    }

    async function startPublishPlaying(roomId, memberId) {
      let controlRoom = await axios.get(controlUrl + roomId);
      var otherMembers = Object.keys(controlRoom.data.element.pipeline);
      var play_requests = [];
      for (let i = 0; i < otherMembers.length; i++) {
        let id = otherMembers[i];

        if (id === memberId) {
          continue;
        }

        let playRequest = axios({
          method: 'post',
          url: controlUrl + roomId + "/" + id + '/play-' + memberId,
          data: {
            kind: 'WebRtcPlayEndpoint',
            src: 'local://' + roomId + '/' + memberId + '/publish',
            force_relay: (controlRoom.data.element.pipeline[id].pipeline.publish || { force_relay: isForceRelay }).force_relay,
          }
        });
        play_requests.push(playRequest);
      }
      await Promise.all(play_requests);
    }

    async function addNewMember(roomId, memberId) {
      let pipeline = {};
      if (isPublishingEnabled) {
        pipeline["publish"] = {
          kind: 'WebRtcPublishEndpoint',
          p2p: 'Always',
          force_relay: isForceRelay,
          audio_settings: {
            publish_policy: audioPublishPolicy,
          },
          video_settings: {
            publish_policy: videoPublishPolicy,
          },
        };
      }

      var otherMembers = Object.values((await axios.get(controlUrl + roomId)).data.element.pipeline);
      for (let i = 0; i < otherMembers.length; i++) {
        let member = otherMembers[i];
        let memberId = member.id;
        if (member.pipeline.hasOwnProperty('publish')) {
          pipeline["play-" + memberId] = {
            kind: 'WebRtcPlayEndpoint',
            src: 'local://' + roomId + '/' + memberId + "/publish",
            force_relay: isForceRelay,
          };
        }
      }

      let resp = await axios({
        method: 'post',
        url: controlUrl + roomId + '/' + memberId,
        data: {
          kind: 'Member',
          credentials: 'test',
          pipeline: pipeline,
        },
      });

      if (!isPublishingEnabled) {
        return resp.data.sids[memberId];
      }

      // Here we repeat get room request to reduce possibility of concurrency
      // bugs, e.g. another user was added to the room since first request.
      await startPublishPlaying(roomId, memberId);

      return resp.data.sids[memberId]
    }

    async function updateLocalVideo(stream) {
      localVideo.srcObject = stream.get_media_stream();
      localVideo.oncanplay = async () => {
        await localVideo.play();
      };
    }

    async function fillMediaDevicesInputs(audio_select, video_select, current_stream) {
      const current_audio = (current_stream.getAudioTracks().pop() || { label: "disable" }).label || "disable";
      const current_video = (current_stream.getVideoTracks().pop() || { label: "disable" }).label || "disable";

      const device_infos = await jason.media_manager().enumerate_devices();
      console.log('Available input and output devices:', device_infos);

      for (const device_info of device_infos) {
        const option = document.createElement('option');
        option.value = device_info.device_id();
        if (device_info.kind() === 'audio') {
          option.text = device_info.label()
            || `Microphone ${audio_select.length + 1}`;
          option.selected = option.text === current_audio;
          audio_select.append(option);
        } else if (device_info.kind() === 'video') {
          option.text = device_info.label()
            || `Camera ${video_select.length + 1}`;
          option.selected = option.text === current_video;
          video_select.append(option);
        }
      }

      const option = document.createElement('option');
      option.value = "screen";
      option.text = "screen";
      video_select.append(option);
    }

    async function build_constraints(audio_select, video_select) {
      let constraints = new MediaStreamSettings();
      if (audio_select != null) {
        let audio = new AudioTrackConstraints();
        let audioSource = audio_select.options[audio_select.selectedIndex];
        if (audioSource) {
          audio.device_id(audioSource.value);
        }
        constraints.audio(audio);
      }

      if (video_select != null) {
        let videoSource = video_select.options[video_select.selectedIndex];
        if (videoSource) {
          if (videoSource.value === "screen") {
            let video = new DisplayVideoTrackConstraints();
            constraints.display_video(video);
          } else {
            let video = new DeviceVideoTrackConstraints();
            video.device_id(videoSource.value);
            constraints.device_video(video);
          }
        } else {
          constraints.device_video(new DeviceVideoTrackConstraints());
        }
      }

      return constraints;
    }

    async function initLocalStream() {
      let constraints = await build_constraints(
        isAudioMuted ? null : audioSelect,
        isVideoMuted ? null : videoSelect
      );
      try {
        localStream = await jason
          .media_manager()
          .init_local_stream(constraints)
      } catch (e) {
        let origError = e.source();
        if (origError && (origError.name === "NotReadableError" || origError.name === "AbortError")) {
          if (origError.message.includes("audio")) {
            constraints = await build_constraints(null, videoSelect);
            localStream = await jason
              .media_manager()
              .init_local_stream(constraints);
            alert("unable to get audio, will try to enter room with video only");
          } else if (origError.message.includes("video")) {
            constraints = await build_constraints(audioSelect, null);
            localStream = await jason
              .media_manager()
              .init_local_stream(constraints);
            alert("unable to get video, will try to enter room with audio only");
          } else {
            throw e;
          }
        } else {
          throw e;
        }
      }
      await updateLocalVideo(localStream);

      return constraints;
    }

    async function isAudioEnabledListener(e) {
      audioPublishPolicy = getPublishPolicy(e.target.checked);

      let constraints;
      if (e.target.checked) {
        constraints = await build_constraints(
          audioSelect,
          isVideoEnabledCheckbox.checked ? videoSelect : null
        );
      } else {
        constraints = await build_constraints(
          null,
          isVideoEnabledCheckbox.checked ? videoSelect : null
        );
      }
      if (localStream.ptr > 0) {
        localStream.free();
      }
      localStream = await jason
        .media_manager()
        .init_local_stream(constraints);
      await updateLocalVideo(localStream);
      await room.set_local_media_settings(constraints);
    }

    async function isVideoEnabledListener(e) {
      videoPublishPolicy = getPublishPolicy(e.target.checked);

      let constraints;
      if (e.target.checked) {
        constraints = await build_constraints(
          isAudioEnabledCheckbox.checked ? audioSelect : null,
          videoSelect
        );
      } else {
        constraints = await build_constraints(
          isAudioEnabledCheckbox.checked ? audioSelect : null, null
        );
      }
      if (localStream.ptr > 0) {
        localStream.free();
      }
      localStream = await jason
        .media_manager()
        .init_local_stream(constraints);
      await updateLocalVideo(localStream);
      await room.set_local_media_settings(constraints);
    }

    function bindJoinButtons(roomId) {
      joinCallerButton.onclick = async function () {
        connectBtnsDiv.style.display = 'none';
        controlBtns.style.display = 'block';

        setCookie(userNameCookieName, usernameInput.value, 365);

        isForceRelay = isForceRelayCheckbox.checked;
        isForceRelayCheckbox.disabled = true;

        if (isPublishingEnabled) {
          // TODO: Remove when delete-tracks will be merged.
          isPublishingEnabledCheckbox.disabled = true;
          isAudioEnabledCheckbox.disabled = true;
          isVideoEnabledCheckbox.disabled = true;
        } else {
          // TODO: Remove when delete-tracks will be merged.
          isPublishingEnabledCheckbox.disabled = false;
          isAudioEnabledCheckbox.disabled = false;
          isVideoEnabledCheckbox.disabled = false;
        }

        try {
          let username = usernameInput.value;
          try {
            await axios.get(controlUrl + roomId);
          } catch (e) {
            if (e.response.status === 400) {
              console.log("Room not found. Creating new room...");
              await createRoom(roomId)
            } else {
              throw e;
            }
          }

          await axios.delete(controlUrl + roomId + '/' + username);
          console.log("Creating new member.");
          await room.join(await addNewMember(roomId, username));
          connectionState.className = 'badge badge-success';
          connectionState.textContent = 'Connected';
          isJoinedRoom = true;

        } catch (e) {
          logError("Join to room failed", e);
        }
      };
    }

    function getPublishPolicy(isEnabled) {
      if (isEnabled) {
        return 'Optional';
      } else {
        return 'Disabled';
      }
    }

    async function init_jason() {
      await init();

      jason = new Jason();
      room = await jason.init_room();

      let userNameFromCookies = getCookie(userNameCookieName);
      if (userNameFromCookies) {
        usernameInput.value = userNameFromCookies;
      }

      isAudioEnabledCheckbox.addEventListener('change', isAudioEnabledListener);
      isVideoEnabledCheckbox.addEventListener('change', isVideoEnabledListener);

      isPublishingEnabledCheckbox.addEventListener('change', async () => {
          isPublishingEnabled = isPublishingEnabledCheckbox.checked;
          if (isPublishingEnabledCheckbox.checked) {
            isAudioEnabledCheckbox.disabled = false;
            isVideoEnabledCheckbox.disabled = false;
            if (isJoinedRoom) {
              await startPublishing(roomId, usernameInput.value);
              isAudioEnabledCheckbox.disabled = true;
              isVideoEnabledCheckbox.disabled = true;
              isPublishingEnabledCheckbox.disabled = true;
            } else {
              isAudioEnabledCheckbox.checked = true;
              isVideoEnabledCheckbox.checked = true;

              await isAudioEnabledListener({target: isAudioEnabledCheckbox});
              await isVideoEnabledListener({target: isVideoEnabledCheckbox});
            }
          } else {
            if (isJoinedRoom) {
              await stopPublishing(roomId, usernameInput.value);
              isAudioEnabledCheckbox.disabled = false;
              isVideoEnabledCheckbox.disabled = false;
            } else {
              isAudioEnabledCheckbox.checked = false;
              isVideoEnabledCheckbox.checked = false;

              await isAudioEnabledListener({target: isAudioEnabledCheckbox});
              await isVideoEnabledListener({target: isVideoEnabledCheckbox});

              isAudioEnabledCheckbox.disabled = true;
              isVideoEnabledCheckbox.disabled = true;
            }
          }
        }
      );

      audioSelect.addEventListener('change', async () => {
        try {
          let constraints = await build_constraints(audioSelect, videoSelect);
          if (localStream && localStream.ptr > 0 ){
            localStream.free();
          }
          if (!isAudioMuted) {
            constraints = await initLocalStream();
          }
          await room.set_local_media_settings(constraints);
        } catch (e) {
          console.error("Changing audio source failed: " + e);
        }
      });

      videoSelect.addEventListener('change', async () => {
        try {
          let constraints = await build_constraints(audioSelect, videoSelect);
          if (localStream && localStream.ptr > 0 ){
            localStream.free();
          }
          if (!isVideoMuted) {
            constraints = await initLocalStream();
          }
          await room.set_local_media_settings(constraints);
        } catch (e) {
          console.error("Changing video source failed: " + e);
        }
      });

      room.on_failed_local_stream(function (error) {
        console.error(error);
      });

      room.on_new_connection((connection) => {
        logsTextArea.value +=  "new connection established" + '\r\n';
        isCallStarted = true;
        let remoteMemberId = connection.get_remote_member_id();
        connection.on_remote_stream(async (stream) => {
          let video = document.createElement("video");
          video.srcObject = stream.get_media_stream();
          video.controls = "true";
          video.style.maxWidth = "100%";

          let innerVideoDiv = document.createElement("div");
          innerVideoDiv.className = "col-md-3";
          innerVideoDiv.appendChild(video);
          let remoteMemberIdEl = document.createElement('span');
          remoteMemberIdEl.innerHTML = remoteMemberId;
          innerVideoDiv.appendChild(remoteMemberIdEl);
          remote_videos[connection.get_remote_id()] = innerVideoDiv;
          videoDiv.appendChild(innerVideoDiv);

          video.oncanplay = async () => {
            await video.play();
          };
        });

        connection.on_close(() => {
          remote_videos[connection.get_remote_id()].remove();
          delete remote_videos[connection.get_remote_id()];
        });
      });

      room.on_local_stream((stream) => {
        updateLocalVideo(stream);
        stream.free();
      });

      room.on_connection_loss(async (reconnectHandle) => {
        connectionState.className = 'badge badge-warning';
        connectionState.textContent = 'Reconnecting';

        try {
          await reconnectHandle.reconnect_with_backoff(500, 1.1, 10000);
          connectionState.className = 'badge badge-success';
          connectionState.textContent = 'Connected';
        } catch (e) {
          console.error(e);
        }
      });

      room.on_close(function (on_closed) {
        connectionState.className = 'badge badge-danger';
        connectionState.textContent = "Closed";
        alert(
          `Call was ended.
          Reason: ${on_closed.reason()};
          Is closed by server: ${on_closed.is_closed_by_server()};
          Is error: ${on_closed.is_err()}.`
        );
      });

      muteAudioBtn.addEventListener('click', async () => {
        try {
          if (isAudioMuted) {
            await room.unmute_audio();
            isAudioMuted = false;
            muteAudioBtn.textContent = "Mute audio";
            if (!isCallStarted) {
              await initLocalStream();
            }
          } else {
            await room.mute_audio();
            if (localStream && localStream.ptr > 0 ){
              localStream.free_audio();
            }
            isAudioMuted = true;
            muteAudioBtn.textContent = "Unmute audio";
          }
        } catch (e) {
          console.error(e.message());
        }
      });
      muteVideoBtn.addEventListener('click', async () => {
        try {
          if (isVideoMuted) {
            await room.unmute_video();
            isVideoMuted = false;
            muteVideoBtn.textContent = "Mute video";
            if (!isCallStarted) {
              await initLocalStream();
            }
          } else {
            await room.mute_video();
            if (localStream && localStream.ptr > 0 ){
              localStream.free_video();
            }
            isVideoMuted = true;
            muteVideoBtn.textContent = "Unmute video";
          }
        } catch (e) {
          console.error(e.message());
        }
      });

      let roomId = window.location.hash.replace("#", "");

      if (roomId) {
        bindJoinButtons(roomId);
        chooseRoomDiv.style.display = "none";
        videoCallDiv.style.display = "";

        try {
          const constraints = await initLocalStream();
          await fillMediaDevicesInputs(audioSelect, videoSelect, localStream.get_media_stream());
          await room.set_local_media_settings(constraints);
        } catch (e) {
          console.error("Init local video failed: " + e);
        }

      } else {
        chooseRoomButton.onclick = async function () {
          let roomId = roomIdInput.value;

          window.location.hash = roomId;
          bindJoinButtons(roomId);

          try {
            const constraints = await initLocalStream();
            await fillMediaDevicesInputs(audioSelect, videoSelect, localStream.get_media_stream());
            await room.set_local_media_settings(constraints);
          } catch (e) {
            console.error("Init local video failed: " + e.message());
          }

          chooseRoomDiv.style.display = "none";
          videoCallDiv.style.display = "";
        };
      }
    }

    window.onload = async function () {
      await init_jason();
    };

    function logError(msg, e) {
      if (e.name && e.message && e.source && e.trace) {
        console.error(
          msg + ": Error[name:[", e.name(), "], ",
          "[msg:", e.message(), "], [source", e.source(), "]]",
        );
        console.error(e.trace());
      } else {
        console.error(e);
      }
    }

    function setCookie(name, value, days) {
      var expires = "";
      if (days) {
        var date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "") + expires + "; path=/";
    }

    function getCookie(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
      }
      return null;
    }
  </script>

</head>
<body>
  <div id="choose-room" class="input-group col-md-3">
    <input id="choose-room__room-id" type="text" class="form-control" placeholder="Room name" aria-label="Room name" aria-describedby="basic-addon2">
    <div class="input-group-append">
      <button id="choose-room__join" class="btn btn-outline-secondary" type="submit">Join Room</button>
    </div>
  </div>

  <div id="video-call" style="display: none">
    <div id="remote-videos" class="row">
    </div>

    <div class="row h-25 w-75">
      <div class="col-md-4">
        <video id="local-video__video" muted autoplay width="100%" height="100%"></video>
      </div>
      <div class="col-md-4">

        <div class="input-group mb-3">
          <input id="join__username" type="text" class="form-control" placeholder="Username" aria-label="Username" aria-describedby="basic-addon2">
          <div class="input-group-append">
            <button id="join__join" class="btn btn-outline-secondary" type="button">Connect</button>
          </div>
        </div>

        <div class="input-group mb-3">
          <div class="input-group-prepend">
            <label class="input-group-text" for="connect__select-device_audio">Audio</label>
          </div>
          <select class="custom-select" id="connect__select-device_audio"></select>
        </div>

        <div class="input-group mb-3">
          <div class="input-group-prepend">
            <label class="input-group-text" for="connect__select-device_video">Video</label>
          </div>
          <select class="custom-select" id="connect__select-device_video"></select>
        </div>

        <div id="control" class="input-group mb-3" style="display: none">
          <button class="btn btn-info" id="control__mute_audio">Mute audio</button>
          <button class="btn btn-info" id="control__mute_video">Mute video</button>
        </div>

        <div class="mb-3">
          <label for="connection-state__state">Connection state: </label>
          <span id="connection-state__state" class="badge badge-danger">Closed</span>
        </div>

        <div class="form-check form-check-inline mb-3">
          <div class="custom-switch">
            <input class="form-check-input custom-control-input"
                   type="checkbox"
                   id="is-audio-enabled"
                   checked>
            <label class="form-check-label custom-control-label"
                   for="is-audio-enabled">
              Publish audio
            </label>
          </div>

          <div class="custom-switch">
            <input class="form-check-input custom-control-input"
                   type="checkbox"
                   id="is-video-enabled"
                   checked>
            <label class="form-check-label custom-control-label"
                   for="is-video-enabled">
              Publish video
            </label>
          </div>

          <div class="custom-switch">
            <input class="form-check-input custom-control-input"
                   type="checkbox"
                   id="is-publishing-enabled"
                   checked>
            <label class="form-check-label custom-control-label"
                   for="is-publishing-enabled">
              Publish media
            </label>
          </div>
        </div>

        <div class="form-check mb-3">
          <div class="custom-switch">
            <input class="form-check-input custom-control-input"
                   type="checkbox"
                   id="is_force_relay"
                   value="true">
            <label class="form-check-label custom-control-label"
                   for="is_force_relay">
              Force TURN relay
            </label>
          </div>
        </div>

      </div>
      <div class="col-md-4">
          <textarea class="form-control" id="logs-output" style="resize: none" rows="14" autocomplete="off" disabled></textarea>
      </div>
    </div>
  </div>
</body>
</html>
